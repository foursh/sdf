import os
import requests
from bs4 import BeautifulSoup
from django.shortcuts import render
from .models import Stock
from .models import StockMetrics

import time
import pandas as pd
from io import StringIO
import io
from contextlib import redirect_stdout
from django.conf import settings
from django.http import HttpResponse, HttpResponseBadRequest, HttpResponseForbidden
from django.views.decorators.csrf import csrf_exempt
from django.http import HttpRequest
from linebot import LineBotApi, WebhookParser
from linebot.exceptions import InvalidSignatureError, LineBotApiError
from linebot.models import MessageEvent, TextSendMessage, QuickReply, QuickReplyButton, MessageAction

#line_bot_api = LineBotApi(settings.LINE_CHANNEL_ACCESS_TOKEN)
#parser = WebhookParser(settings.LINE_CHANNEL_SECRET)

from langchain.chains import LLMChain
from langchain_core.prompts import (
    ChatPromptTemplate,
    HumanMessagePromptTemplate,
    MessagesPlaceholder,
)
from langchain_core.messages import SystemMessage
from langchain.chains.conversation.memory import ConversationBufferWindowMemory
from langchain_groq import ChatGroq
from dotenv import load_dotenv
'''
# Loading environment variables from .env file
load_dotenv()
# Function to initialize conversation chain with GROQ language model
groq_api_key = os.environ['GROQ_API_KEY']

def chatbot(question):
    model = 'llama3-8b-8192'
    # Initialize Groq Langchain chat object and conversation
    groq_chat = ChatGroq(groq_api_key=groq_api_key, model_name=model)

    #print("Hello! I'm your friendly Groq chatbot. I can help answer your questions, provide information, or just chat. I'm also super fast! Let's start our conversation!")
    
    system_prompt = 'You are a friendly conversational chatbot'
    conversational_memory_length = 5  # number of previous messages the chatbot will remember during the conversation

    memory = ConversationBufferWindowMemory(k=conversational_memory_length,
                                            memory_key="chat_history",
                                            return_messages=True)
    
    

    #chat_history = []
    # while True:
    user_question = question+"全部的內容都要完全用繁體中文回話，並且內容要基於台灣的現實情況。這個問題是關於金融方面的問題，請以金融方面作回答。"

    # If the user has asked a question,
    if user_question:

        # Construct a chat prompt template using various components
        prompt = ChatPromptTemplate.from_messages([
            SystemMessage(
                content=system_prompt
            ),  # This is the persistent system prompt that is always included at the start of the chat.
            MessagesPlaceholder(
                variable_name="chat_history"
            ),  # This placeholder will be replaced by the actual chat history during the conversation. It helps in maintaining context.
            HumanMessagePromptTemplate.from_template(
                "{human_input}"
            ),  # This template is where the user's current input will be injected into the prompt.
        ])

        print('memory:', memory)
        # Create a conversation chain using the LangChain LLM (Language Learning Model)
        conversation = LLMChain(
            llm=groq_chat,  # The Groq LangChain chat object initialized earlier.
            prompt=prompt,  # The constructed prompt template.
            verbose=False,  # TRUE Enables verbose output, which can be useful for debugging.
            memory=memory,  # The conversational memory object that stores and manages the conversation history.
        )
        # The chatbot's answer is generated by sending the full prompt to the Groq API.
        response = conversation.predict(human_input=user_question)
        #print("Chatbot:", response)
        
        print(memory.buffer)
        
        return response


'''

@csrf_exempt
def callback(request):
    if request.method == 'POST':
        signature = request.META.get('HTTP_X_LINE_SIGNATURE')
        body = request.body.decode('utf-8')

        if not signature or not body:
            return HttpResponseBadRequest()

        try:
            events = parser.parse(body, signature)
        except InvalidSignatureError:
            return HttpResponseForbidden()
        except LineBotApiError:
            return HttpResponseBadRequest()

        for event in events:
            if isinstance(event, MessageEvent):
                user_message = event.message.text.strip()
                
                if user_message.isdigit():
                    stock_code = user_message
                    try:
                        mock_request = HttpRequest()
                        mock_request.method = 'POST'
                        mock_request.POST = {'stock_code': stock_code}

                        f = io.StringIO()
                        with redirect_stdout(f):
                            query_report(mock_request)
                        output = f.getvalue()

                        filtered_output = "\n".join([
                            line for line in output.split("\n")
                            if "計算" not in line
                        ])

                        scores = {}
                        for line in filtered_output.split('\n'):
                            if '分數:' in line:
                                key, value = line.split(':')
                                scores[key.strip()] = value.strip()

                        if scores:
                            response_message = f"股票代號 {stock_code} ：\n"
                            for key, value in scores.items():
                                response_message += f"{key}: {value}\n"
                        else:
                            response_message = "無法獲取股票分數資訊。"

                        quick_reply = QuickReply(items=[
                            QuickReplyButton(action=MessageAction(label="查詢說明", text="查詢說明")),
                        ])

                        line_bot_api.reply_message(
                            event.reply_token,
                            TextSendMessage(text=response_message, quick_reply=quick_reply)
                        )
                    except Exception as e:
                        print(f"發生異常: {str(e)}")
                        line_bot_api.reply_message(
                            event.reply_token,
                            TextSendMessage(text=f"查詢時發生錯誤: {str(e)}")
                        )
                elif user_message == "查詢說明":
                    quick_reply = QuickReply(items=[
                        QuickReplyButton(action=MessageAction(label="查詢說明", text="查詢說明")),
                    ])
                    line_bot_api.reply_message(
                        event.reply_token,
                        TextSendMessage(text="請直接輸入股票代號來查詢股票資訊。（例如：2330）", quick_reply=quick_reply)
                    )
                else:
                    # Call the chatbot function for other messages
                    response_message = chatbot(user_message)  # Call chatbot with user message
                    line_bot_api.reply_message(
                        event.reply_token,
                        TextSendMessage(text=response_message)
                    )

        return HttpResponse()
    else:
        return HttpResponseBadRequest()


def fetch_reports(stock_code):
    urls = [
        'https://mops.twse.com.tw/mops/web/ajax_t164sb03',
        'https://mops.twse.com.tw/mops/web/ajax_t164sb04',
        'https://mops.twse.com.tw/mops/web/ajax_t164sb05'
    ]
    results = []

    for url in urls:
        form_data = {
            'encodeURIComponent': 1,
            'step': 1,  # 初始設置 step 為 1
            'firstin': 1,
            'off': 1,
            'co_id': stock_code,
            'TYPEK': 'all',
            'isnew': 'true'
        }

        for attempt in range(2):  # 嘗試兩次，第一次 step = 1，第二次 step = 2
            try:
                response = requests.post(url, data=form_data)
                response.raise_for_status()
                
                # 使用 BeautifulSoup 解析 HTML
                soup = BeautifulSoup(response.text, 'html.parser')
                tables = soup.find_all('table')
                
                if len(tables) > 1:
                    # 提取表格資料並轉換為 HTML
                    table_html = str(tables[1])
                    results.append(table_html)
                    break  # 如果成功獲取報告，跳出嘗試循環
                else:
                    if attempt == 0:
                        form_data['step'] = 2  # 如果第一次嘗試失敗，將 step 更改為 2
                
            except requests.RequestException:
                if attempt == 0:
                    form_data['step'] = 2  # 如果第一次嘗試失敗，將 step 更改為 2

            time.sleep(2)  # 每次嘗試後暫停 2 秒
        
        if not results:
            print(f"爬取失敗：{url}")
    
    return results



def save_reports(stock_code, reports):
    if len(reports) >= 3:
        # 嘗試找到現有的記錄，如果不存在則創建一個新的
        stock, created = Stock.objects.get_or_create(stock_code=stock_code)
        
        # 更新報表數據
        stock.B = reports[0]
        stock.P = reports[1]
        stock.C = reports[2]
        stock.save()



def validate_and_save_reports_from_csv(csv_file_path, batch_size=5):
    df = pd.read_csv(csv_file_path, encoding='big5')
    stock_codes = df['code'].tolist()
    failed_stock_codes = []  # 用於記錄失敗的股票代號
    updated_stock_codes = []  # 用於記錄成功更新的股票代號

    for i in range(0, len(stock_codes), batch_size):
        batch = stock_codes[i:i + batch_size]
        print(f"Processing batch {i // batch_size + 1} with stock codes: {batch}")

        for stock_code in batch:
            print(f"Processing stock code: {stock_code}")
            attempts = 0
            max_attempts = 2
            reports = None

            while attempts < max_attempts:
                reports = fetch_reports(stock_code)
                if reports:
                    save_reports(stock_code, reports)
                    print(f"Reports for {stock_code} saved and updated successfully.")
                    updated_stock_codes.append(stock_code)  # 記錄成功更新的股票代號
                    break
                else:
                    attempts += 1
                    print(f"Attempt {attempts} failed. Retrying...")
                    time.sleep(5)

            if not reports:
                print(f"Failed to fetch reports for {stock_code} after {max_attempts} attempts. Recording failure.")
                failed_stock_codes.append(stock_code)  # 記錄失敗的股票代號

    return failed_stock_codes, updated_stock_codes  # 返回失敗的和成功更新的股票代號



def query_report(request):
    if request.method == 'POST':
        stock_code = request.POST.get('stock_code')
        if stock_code:
            try:
                # 從資料庫獲取股票資料
                stock = Stock.objects.get(stock_code=stock_code)

                # 轉換 HTML 內容為 DataFrame
                def html_to_df(html):
                    try:
                        return pd.read_html(StringIO(html))[0]
                    except ValueError:
                        return pd.DataFrame()  # 返回空的 DataFrame，表示找不到表格
                
                df_B = html_to_df(stock.B)
                df_P = html_to_df(stock.P)
                df_C = html_to_df(stock.C)



                # 根據實際需要刪除其他不必要的欄位
                df_B = df_B.iloc[:, :-2]  # 根據實際需要調整
                df_P = df_P.iloc[:, :-1]  # 根據實際需要調整
                df_C = df_C.iloc[:, :-4]  # 根據實際需要調整

                # 如果 DataFrame 是空的，顯示未找到報表的訊息
                if df_B.empty and df_P.empty and df_C.empty:
                    print('未找到報表')
                    return

                # 提取數據的內嵌函數
                def extract_data_from_html(html_content):
                    soup = BeautifulSoup(html_content, 'html.parser')
                    data = {}

                    # 可指定提取哪一列的值
                    def extract_value(label, column_index=1, occurrence=1):
                        found_values = []
                        rows = soup.find_all('tr')
                        for row in rows:
                            columns = row.find_all('td')
                            if len(columns) > column_index:
                                cell_label = columns[0].get_text(strip=True)
                                if cell_label == label:
                                    found_values.append(columns[column_index].get_text(strip=True))
                        if occurrence <= len(found_values):
                            return found_values[occurrence - 1]
                        return None

                    return {
                        '現金及約當現金': extract_value('現金及約當現金'),
                        '負債總額': extract_value('負債總額') or extract_value('負債總計'),
                        '資產總額': extract_value('資產總額') or extract_value('資產總計'),
                        '應收帳款淨額': extract_value('應收帳款淨額') or extract_value('應收款項－淨額'),  # 取第三列
                        '營業收入合計': extract_value('營業收入合計') or extract_value('淨收益'),
                        '毛利率': extract_value('營業毛利（毛損）', column_index=2),  
                        '營業利益率': extract_value('營業利益（損失）', column_index=2),
                        '淨利率': extract_value('本期淨利（淨損）', column_index=2) or extract_value('本期稅後淨利（淨損）', column_index=2),
                        '本期淨利（淨損）': extract_value('本期淨利（淨損）') or extract_value('本期稅後淨利（淨損）'),
                        'EPS': extract_value('基本每股盈餘', occurrence=2),  # 取第二個
                        '權益總額': extract_value('權益總額') or extract_value('權益總計'),
                        '非流動資產合計': extract_value('非流動資產合計'),
                        '非流動負債合計': extract_value('非流動負債合計'),
                        '流動資產合計': extract_value('流動資產合計'),
                        '流動負債合計': extract_value('流動負債合計'),
                        '發放現金股利': extract_value('發放現金股利'),
                        '存貨': extract_value('存貨'),

                        '應收款項－淨額': extract_value('應收款項－淨額'),
                        '附賣回票券及債券投資': extract_value('附賣回票券及債券投資'),
                        '不動產及設備－淨額': extract_value('不動產及設備－淨額'),
                        '投資性不動產－淨額': extract_value('投資性不動產－淨額'),
                        '使用權資產－淨額': extract_value('使用權資產－淨額'),
                        '無形資產－淨額': extract_value('無形資產－淨額'),

                    }

                # 提取數據
                results_B = extract_data_from_html(stock.B)
                results_P = extract_data_from_html(stock.P)
                results_C = extract_data_from_html(stock.C)

                # 合併數據
                combined_results = {}
                combined_results.update({k: v for k, v in results_B.items() if v is not None})
                combined_results.update({k: v for k, v in results_P.items() if v is not None})
                combined_results.update({k: v for k, v in results_C.items() if v is not None})

                # 計算額外的數據
                calculations = {}
                score_data = {}
                try:
                    毛利率 = float(combined_results.get('毛利率', '0').replace(',', ''))
                    營業利益率 = float(combined_results.get('營業利益率', '0').replace(',', ''))
                    本期淨利 = float(combined_results.get('本期淨利（淨損）', '0').replace(',', ''))
                    權益總額 = float(combined_results.get('權益總額', '0').replace(',', ''))
                    淨利率 = float(combined_results.get('淨利率', '0').replace(',', ''))
                    EPS = float(combined_results.get('EPS', '0').replace(',', ''))
                    負債總額 = float(combined_results.get('負債總額', '0').replace(',', ''))
                    資產總額 = float(combined_results.get('資產總額', '0').replace(',', ''))
                    現金及約當現金 = float(combined_results.get('現金及約當現金', '0').replace(',', ''))
                    應收帳款 = float(combined_results.get('應收帳款淨額', '0').replace(',', ''))
                    營業收入 = float(combined_results.get('營業收入合計', '0').replace(',', ''))
                    流動資產 = float(combined_results.get('流動資產合計', '0').replace(',', ''))
                    存貨 = float(combined_results.get('存貨', '0').replace(',', ''))
                    股利 = float(combined_results.get('發放現金股利', '0').replace(',', ''))
                    非流動資產 = float(combined_results.get('非流動資產合計', '0').replace(',', ''))
                    非流動負債 = float(combined_results.get('非流動負債合計', '0').replace(',', ''))
                    流動負債 = float(combined_results.get('流動負債合計', '0').replace(',', ''))
                    應收款項 = float(combined_results.get('應收款項－淨額', '0').replace(',', ''))
                    附賣回票券及債券投資 = float(combined_results.get('附賣回票券及債券投資', '0').replace(',', ''))
                    不動產及設備 = float(combined_results.get('不動產及設備－淨額', '0').replace(',', ''))
                    投資性不動產 = float(combined_results.get('投資性不動產－淨額', '0').replace(',', ''))
                    使用權資產 = float(combined_results.get('使用權資產－淨額', '0').replace(',', ''))
                    無形資產 = float(combined_results.get('無形資產－淨額', '0').replace(',', ''))


                    #輸出值等於零的鍵
                    # 新建一個字典來存放變數和值
                    financial_data = {
                        '毛利率': float(combined_results.get('毛利率', '0').replace(',', '')),
                        '營業利益率': float(combined_results.get('營業利益率', '0').replace(',', '')),
                        '本期淨利': float(combined_results.get('本期淨利（淨損）', '0').replace(',', '')),
                        '權益總額': float(combined_results.get('權益總額', '0').replace(',', '')),
                        '淨利率': float(combined_results.get('淨利率', '0').replace(',', '')),
                        'EPS': float(combined_results.get('EPS', '0').replace(',', '')),
                        '負債總額': float(combined_results.get('負債總額', '0').replace(',', '')),
                        '資產總額': float(combined_results.get('資產總額', '0').replace(',', '')),
                        '現金及約當現金': float(combined_results.get('現金及約當現金', '0').replace(',', '')),
                        '應收帳款': float(combined_results.get('應收帳款淨額', '0').replace(',', '')),
                        '營業收入': float(combined_results.get('營業收入合計', '0').replace(',', '')),
                        '流動資產': float(combined_results.get('流動資產合計', '0').replace(',', '')),
                        '存貨': float(combined_results.get('存貨', '0').replace(',', '')),
                        '股利': float(combined_results.get('發放現金股利', '0').replace(',', '')),
                        '非流動資產': float(combined_results.get('非流動資產合計', '0').replace(',', '')),
                        '非流動負債': float(combined_results.get('非流動負債合計', '0').replace(',', '')),
                        '流動負債': float(combined_results.get('流動負債合計', '0').replace(',', '')),
                        '應收款項': float(combined_results.get('應收款項－淨額', '0').replace(',', '')),
                        '附賣回票券及債券投資': float(combined_results.get('附賣回票券及債券投資', '0').replace(',', '')),
                        '不動產及設備': float(combined_results.get('不動產及設備－淨額', '0').replace(',', '')),
                        '投資性不動產': float(combined_results.get('投資性不動產－淨額', '0').replace(',', '')),
                        '使用權資產': float(combined_results.get('使用權資產－淨額', '0').replace(',', '')),
                        '無形資產': float(combined_results.get('無形資產－淨額', '0').replace(',', '')),
                    }
                    
                    # 將值等於零的鍵連接成一行輸出在終端機
                    zero_keys = [key for key, value in financial_data.items() if value == 0]
                    if zero_keys:
                        print(f"值等於零的鍵: {', '.join(zero_keys)}")




                    if 流動資產 == 0:
                        # 計算流動負債的值 (假設你有其他計算方法，這裡以示例計算)
                        流動資產 = 現金及約當現金 + 應收款項 + 附賣回票券及債券投資
                        calculations['流動資產'] = f'{流動資產:.2f}'

                    if 非流動資產 == 0:
                        非流動資產=不動產及設備 + 投資性不動產 + 使用權資產 + 無形資產
                        calculations['非流動資產'] = f'{非流動資產:.2f}'

                    if 股利 == 0:
                        csv_file_path = os.path.join(os.path.dirname(__file__), 'csv', 'day.csv')
                        # 檢查 CSV 檔案是否存在
                        if os.path.exists(csv_file_path):
                            # 讀取 CSV 檔案，指定編碼
                            df_csv = pd.read_csv(csv_file_path, encoding='big5')
                            
                            # 確保 CSV 中包含 'code' 和 'day' 欄位
                            if 'code' in df_csv.columns and 'dividend' in df_csv.columns:
                                # 將 'code' 欄位轉換為數字型別
                                df_csv['code'] = pd.to_numeric(df_csv['code'], errors='coerce')
                                
                                # 將使用者輸入的 stock_code 轉換為數字型別
                                try:
                                    stock_code_numeric = float(stock_code)
                                except ValueError:
                                    print(f"使用者輸入的 code '{stock_code}' 不是有效的數字。")
                                    stock_code_numeric = None
                                
                                if stock_code_numeric is not None:
                                    # 查找使用者輸入的 code 對應的行
                                    matching_rows = df_csv[df_csv['code'] == stock_code_numeric]

                                    # 檢查是否找到了對應的行
                                    if not matching_rows.empty:
                                        股利= matching_rows['dividend'].values[0]  
                                        calculations['股利'] = 股利
                                    else:
                                        print(f"CSV 檔案中找不到 code '{stock_code}' 的數據")
                                else:
                                    print("無法將使用者輸入的 code 轉換為數字。")
                            else:
                                print("CSV 檔案中找不到 'code' 或 'dividend' 欄位")
                        else:
                            print("CSV 檔案不存在")

                    # 損益表
                    if 毛利率 :
                        毛利率_20 = 毛利率 * 0.2
                        calculations['毛利率'] = 毛利率
                        score_data['毛利率_20'] = f'{毛利率_20:.2f}'
                    else:
                        毛利率 = 0
                        score_data['毛利率_20'] = 0
                        calculations['毛利率'] = 毛利率

                    if 營業利益率 :
                        營業利益率_20 = 營業利益率 * 0.2
                        score_data['營業利益率_20'] = f'{營業利益率_20:.2f}' 
                        calculations['營業利益率'] = 營業利益率
                    else:
                        營業利益率 = 0
                        score_data['營業利益率_20'] = 0                   
                        calculations['營業利益率'] = 營業利益率

                    if 毛利率 :
                        經營安全邊際 = 營業利益率 / 毛利率
                        if 經營安全邊際 > 0.6:
                            經營安全邊際_20 = 20
                        else:
                            經營安全邊際_20 = 經營安全邊際 * (100 / 3)
                        calculations['經營安全邊際'] = f'{經營安全邊際:.2f}'
                        score_data['經營安全邊際_20'] = f'{經營安全邊際_20:.2f}'
                    else:
                        經營安全邊際 = 0
                        calculations['經營安全邊際'] = 0
                        score_data['經營安全邊際_20'] = 0                       

                    if 淨利率 != 0:
                        淨利率_10 = 淨利率 * 0.1
                        score_data['淨利率_10'] = f'{淨利率_10:.2f}'
                        calculations['淨利率'] = 淨利率

                    if EPS :
                        EPS_10 = EPS * 0.1
                        score_data['EPS_10'] = f'{EPS_10:.2f}'
                        calculations['EPS'] = EPS

                    if (本期淨利 != 0) and (權益總額 != 0):
                        ROE = 本期淨利 / 權益總額
                        if ROE > 0.2:
                            ROE_20 = 20
                        else:
                            ROE_20 = ROE * 100
                        calculations['ROE'] = f'{ROE:.2f}'
                        score_data['ROE_20'] = f'{ROE_20:.2f}'

                    # 資產負債表
                    if (權益總額 != 0) and (資產總額 != 0):
                        財務槓桿 = 權益總額 / 資產總額
                        財務槓桿_50 = 財務槓桿 * 50
                        calculations['財務槓桿'] = f'{財務槓桿:.2f}'
                        score_data['財務槓桿_50'] = f'{財務槓桿_50:.2f}'
                    else:
                        財務槓桿 = 0
                        calculations['財務槓桿'] = f'{應收帳款收現日:.2f}'

                    if (現金及約當現金 != 0) and (資產總額 != 0):
                        現金及約當現金_資產總額 = 現金及約當現金 / 資產總額
                        if 現金及約當現金_資產總額 < 0.1:
                            現金及約當現金_資產總額_p = 0
                        elif 現金及約當現金_資產總額 > 0.25:
                            現金及約當現金_資產總額_p = (現金及約當現金_資產總額 - 0.25) * 5
                        else:
                            現金及約當現金_資產總額_p = 5
                        calculations['現金及約當現金_資產總額'] = f'{現金及約當現金_資產總額:.2f}'
                        score_data['現金及約當現金_資產總額_p'] = f'{現金及約當現金_資產總額_p:.2f}'

                    if 應收帳款 :
                        應收帳款收現日 = (應收帳款 / 營業收入) * 365
                        應收帳款收現日_25 = 應收帳款收現日 * 0.25
                        if 應收帳款收現日_25 > 25:
                            應收帳款收現日_25 = 25
                        calculations['應收帳款收現日'] = f'{應收帳款收現日:.2f}'
                        score_data['應收帳款收現日_25'] = f'{應收帳款收現日_25:.2f}'
                    else:
                        應收帳款收現日 = 0
                        calculations['應收帳款收現日'] = f'{應收帳款收現日:.2f}'







                    # 計算總計
                    B = 0
                    print("計算資產負債表分數:")
                    for key in ['財務槓桿_50', '現金及約當現金_資產總額_p', '應收帳款收現日_25', 'day_25']:
                        value = score_data.get(key, 0)  # 預設值設為整數 0
                        try:
                            B += float(value)
                            print(f"{key}: {value}, 累加後的B: {B}")
                        except ValueError:
                            print(f"{key}: 無效值 '{value}', 略過此項目")
                    score_data['資產負債表分數'] = f'{B:.2f}' 
                    print(f"資產負債表分數: {score_data['資產負債表分數']}\n")

                    # 計算綜合損益表分數
                    P = 0
                    print("計算綜合損益表分數:")
                    for key in ['毛利率_20', '營業利益率_20', '經營安全邊際_20', '淨利率_10', 'EPS_10', 'ROE_20']:
                        value = score_data.get(key, 0)  # 預設值設為整數 0
                        try:
                            P += float(value)
                            print(f"{key}: {value}, 累加後的P: {P}")
                        except ValueError:
                            print(f"{key}: 無效值 '{value}', 略過此項目")
                    score_data['綜合損益表分數'] = f'{P:.2f}'
                    print(f"綜合損益表分數: {score_data['綜合損益表分數']}\n")


                    #排序
                    from collections import defaultdict

                    # 提取數據，這裡提取所有需要的欄位
                    data_list = StockMetrics.objects.values_list(
                        'stock_code', '毛利率', '營業利益率', '淨利率', 'EPS',
                        '經營安全邊際', 'ROE', '財務槓桿', '應收帳款收現日',
                        '銷貨天數', '加分項'
                    )

                    # 格式化數據
                    gross_margin_list = [{item[0]: item[1]} for item in data_list]  # 毛利率
                    operating_margin_list = [{item[0]: item[2]} for item in data_list]  # 營業利益率
                    net_margin_list = [{item[0]: item[3]} for item in data_list]  # 淨利率
                    eps_list = [{item[0]: item[4]} for item in data_list]  # EPS
                    safety_margin_list = [{item[0]: item[5]} for item in data_list]  # 經營安全邊際
                    roe_list = [{item[0]: item[6]} for item in data_list]  # ROE
                    financial_leverage_list = [{item[0]: item[7]} for item in data_list]  # 財務槓桿
                    ar_days_list = [{item[0]: item[8]} for item in data_list]  # 應收帳款收現日
                    sales_days_list = [{item[0]: item[9]} for item in data_list]  # 銷貨天數
                    extra_points_list = [{item[0]: item[10]} for item in data_list]  # 加分項

                    # 使用者輸入的股票代號
                    user_input_stock_code = stock_code  # 假設這是用戶輸入的代號

                    def calculate_percentage_position(sorted_list, stock_code):
                        # 計算不同名次的數量
                        unique_values = sorted(set(list(item.values())[0] for item in sorted_list))
                        total_unique_stocks = len(unique_values)

                        # 計算每個值對應的名次，處理相同值共享相同名次的情況
                        value_to_rank = {}
                        rank = 1

                        for value in unique_values:
                            value_to_rank[value] = rank
                            rank += 1

                        # 獲取用戶股票的毛利率
                        user_stock_position = next((item for item in sorted_list if stock_code in item), None)
                        if user_stock_position is not None:
                            stock_value = list(user_stock_position.values())[0]
                            # 獲取該股票的名次
                            user_rank = value_to_rank[stock_value]
                            # 計算百分比位置，分母為不同名次的數量
                            percent_position = (user_rank / total_unique_stocks) * 100
                            return percent_position
                        else:
                            return None


                    # 加總變量
                    sum_part1 = 0  # 財務槓桿、應收帳款收現日、銷貨天數
                    sum_part2 = 0  # 毛利率、營業利益率、經營安全邊際、淨利率、EPS、ROE


                    # 初始化結果字典
                    results_dict = {}
                    
                    # 毛利率
                    sorted_gross_margin_list = sorted(gross_margin_list, key=lambda x: list(x.values())[0], reverse=False)  # 由小到大
                    gross_margin_percentage = calculate_percentage_position(sorted_gross_margin_list, user_input_stock_code)
                    weighted_gross_margin = round(gross_margin_percentage * 0.2, 2)  # 四捨五入到小數點第二位
                    results_dict['毛利率'] = round(gross_margin_percentage, 2)  # 四捨五入
                    results_dict['毛利率_weighted'] = weighted_gross_margin  # 分開存放權重
                    sum_part2 += weighted_gross_margin  # 加到第二部分

                    # 營業利益率
                    sorted_operating_margin_list = sorted(operating_margin_list, key=lambda x: list(x.values())[0], reverse=False)  # 由小到大
                    operating_margin_percentage = calculate_percentage_position(sorted_operating_margin_list, user_input_stock_code)
                    weighted_operating_margin = round(operating_margin_percentage * 0.2, 2)  # 四捨五入到小數點第二位
                    results_dict['營業利益率'] = round(operating_margin_percentage, 2)  # 四捨五入
                    results_dict['營業利益率_weighted'] = weighted_operating_margin  # 分開存放權重
                    sum_part2 += weighted_operating_margin  # 加到第二部分

                    # 淨利率
                    sorted_net_margin_list = sorted(net_margin_list, key=lambda x: list(x.values())[0], reverse=False)  # 由小到大
                    net_margin_percentage = calculate_percentage_position(sorted_net_margin_list, user_input_stock_code)
                    weighted_net_margin = round(net_margin_percentage * 0.1, 2)  # 四捨五入到小數點第二位
                    results_dict['淨利率'] = round(net_margin_percentage, 2)  # 四捨五入
                    results_dict['淨利率_weighted'] = weighted_net_margin  # 分開存放權重
                    sum_part2 += weighted_net_margin  # 加到第二部分

                    # EPS
                    sorted_eps_list = sorted(eps_list, key=lambda x: list(x.values())[0], reverse=False)  # 由小到大
                    eps_percentage = calculate_percentage_position(sorted_eps_list, user_input_stock_code)
                    weighted_eps = round(eps_percentage * 0.1, 2)  # 四捨五入到小數點第二位
                    results_dict['EPS'] = round(eps_percentage, 2)  # 四捨五入
                    results_dict['EPS_weighted'] = weighted_eps  # 分開存放權重
                    sum_part2 += weighted_eps  # 加到第二部分

                    # 經營安全邊際
                    sorted_safety_margin_list = sorted(safety_margin_list, key=lambda x: list(x.values())[0], reverse=False)  # 由小到大
                    safety_margin_percentage = calculate_percentage_position(sorted_safety_margin_list, user_input_stock_code)
                    weighted_safety_margin = round(safety_margin_percentage * 0.2, 2)  # 四捨五入到小數點第二位
                    results_dict['經營安全邊際'] = round(safety_margin_percentage, 2)  # 四捨五入
                    results_dict['經營安全邊際_weighted'] = weighted_safety_margin  # 分開存放權重
                    sum_part2 += weighted_safety_margin  # 加到第二部分

                    # ROE
                    sorted_roe_list = sorted(roe_list, key=lambda x: list(x.values())[0], reverse=False)  # 由小到大
                    roe_percentage = calculate_percentage_position(sorted_roe_list, user_input_stock_code)
                    weighted_roe = round(roe_percentage * 0.2, 2)  # 四捨五入到小數點第二位
                    results_dict['ROE'] = round(roe_percentage, 2)  # 四捨五入
                    results_dict['ROE_weighted'] = weighted_roe  # 分開存放權重
                    sum_part2 += weighted_roe  # 加到第二部分

                    # 財務槓桿
                    sorted_financial_leverage_list = sorted(financial_leverage_list, key=lambda x: list(x.values())[0], reverse=False)  # 由小到大
                    financial_leverage_percentage = calculate_percentage_position(sorted_financial_leverage_list, user_input_stock_code)
                    weighted_financial_leverage = round(financial_leverage_percentage * 0.5, 2)  # 四捨五入到小數點第二位
                    results_dict['財務槓桿'] = round(financial_leverage_percentage, 2)  # 四捨五入
                    results_dict['財務槓桿_weighted'] = weighted_financial_leverage  # 分開存放權重
                    sum_part1 += weighted_financial_leverage  # 加到第一部分

                    # 應收帳款收現日（由小到大）
                    sorted_ar_days_list = sorted(ar_days_list, key=lambda x: list(x.values())[0], reverse=False)  # 由小到大
                    ar_days_percentage = calculate_percentage_position(sorted_ar_days_list, user_input_stock_code)
                    weighted_ar_days = round(ar_days_percentage * 0.25, 2)  # 四捨五入到小數點第二位
                    results_dict['應收帳款收現日'] = round(ar_days_percentage, 2)  # 四捨五入
                    results_dict['應收帳款收現日_weighted'] = weighted_ar_days  # 分開存放權重
                    sum_part1 += weighted_ar_days  # 加到第一部分

                    # 銷貨天數（由小到大）
                    sorted_sales_days_list = sorted(sales_days_list, key=lambda x: list(x.values())[0], reverse=False)  # 由小到大
                    sales_days_percentage = calculate_percentage_position(sorted_sales_days_list, user_input_stock_code)
                    weighted_sales_days = round(sales_days_percentage * 0.25, 2)  # 四捨五入到小數點第二位
                    results_dict['銷貨天數'] = round(sales_days_percentage, 2)  # 四捨五入
                    results_dict['銷貨天數_weighted'] = weighted_sales_days  # 分開存放權重
                    sum_part1 += weighted_sales_days  # 加到第一部分

                    # 加分項
                    sorted_extra_points_list = sorted(extra_points_list, key=lambda x: list(x.values())[0], reverse=False)  # 由小到大
                    extra_points_percentage = calculate_percentage_position(sorted_extra_points_list, user_input_stock_code)
                    weighted_extra_points = round(extra_points_percentage * 1, 2)  # 假設加分項本身就是滿分
                    results_dict['加分項'] = round(extra_points_percentage, 2)  # 四捨五入
                    results_dict['加分項_weighted'] = weighted_extra_points  # 分開存放權重

                    results_dict['資產負債表分數'] = round(sum_part1, 2)  # 資產負債表，四捨五入
                    results_dict['綜合損益表分數'] = round(sum_part2, 2)  # 綜合損益表，四捨五入

                    # 輸出結果
                    for key, value in results_dict.items():
                        if isinstance(value, dict):
                            print(f"{key}: 百分比 = {value['percentage']:.2f}, 加權 = {value['weighted']:.2f}")
                        else:
                            print(f"{key}: {value:.2f}")

                    #輸出排序結果和百分比
                    # print("Sorted Gross Margin:", sorted_gross_margin_list, "Percentage Position:", gross_margin_percentage)
                    # print("Sorted Operating Margin:", sorted_operating_margin_list, "Percentage Position:", operating_margin_percentage)
                    # print("Sorted Net Margin:", sorted_net_margin_list, "Percentage Position:", net_margin_percentage)
                    # print("Sorted EPS:", sorted_eps_list, "Percentage Position:", eps_percentage)
                    # print("Sorted Safety Margin:", sorted_safety_margin_list, "Percentage Position:", safety_margin_percentage)
                    # print("Sorted ROE:", sorted_roe_list, "Percentage Position:", roe_percentage)
                    # print("Sorted Financial Leverage:", sorted_financial_leverage_list, "Percentage Position:", financial_leverage_percentage)
                    # print("Sorted AR Days:", sorted_ar_days_list, "Percentage Position:", ar_days_percentage)
                    # print("Sorted Sales Days:", sorted_sales_days_list, "Percentage Position:", sales_days_percentage)
                    # print("Sorted Extra Points:", sorted_extra_points_list, "Percentage Position:", extra_points_percentage)

                    def assign_rank(sorted_list, stock_code):
                        # 提取所有值並計算唯一值
                        values = [list(item.values())[0] for item in sorted_list]
                        unique_values = sorted(set(values), reverse=True)  # 由大到小排序

                        # 計算每個值對應的名次，處理相同值共享相同名次的情況
                        value_to_rank = {}
                        rank = 1

                        for value in unique_values:
                            value_to_rank[value] = rank
                            rank += values.count(value)  # 跳過相同值的數量

                        # 獲取用戶股票的排名
                        user_stock_position = next((item for item in sorted_list if stock_code in item), None)
                        if user_stock_position is not None:
                            stock_value = list(user_stock_position.values())[0]
                            # 獲取該股票的名次
                            user_rank = value_to_rank[stock_value]
                            return user_rank  # 返回用戶股票的排名
                        else:
                            return None  # 如果找不到該股票，返回 None

                    # 假設 user_input_stock_code 是用戶輸入的股票代號
                    # 毛利率
                    sorted_gross_margin = sorted(gross_margin_list, key=lambda x: list(x.values())[0], reverse=True)  # 由大到小
                    gross_margin_rank = assign_rank(sorted_gross_margin, user_input_stock_code)

                    # 營業利益率
                    sorted_operating_margin = sorted(operating_margin_list, key=lambda x: list(x.values())[0], reverse=True)  # 由大到小
                    operating_margin_rank = assign_rank(sorted_operating_margin, user_input_stock_code)

                    # 淨利率
                    sorted_net_margin = sorted(net_margin_list, key=lambda x: list(x.values())[0], reverse=True)  # 由大到小
                    net_margin_rank = assign_rank(sorted_net_margin, user_input_stock_code)

                    # EPS
                    sorted_eps = sorted(eps_list, key=lambda x: list(x.values())[0], reverse=True)  # 由大到小
                    eps_rank = assign_rank(sorted_eps, user_input_stock_code)

                    # 經營安全邊際
                    sorted_safety_margin = sorted(safety_margin_list, key=lambda x: list(x.values())[0], reverse=True)  # 由大到小
                    safety_margin_rank = assign_rank(sorted_safety_margin, user_input_stock_code)

                    # ROE
                    sorted_roe = sorted(roe_list, key=lambda x: list(x.values())[0], reverse=True)  # 由大到小
                    roe_rank = assign_rank(sorted_roe, user_input_stock_code)

                    # 財務槓桿
                    sorted_financial_leverage = sorted(financial_leverage_list, key=lambda x: list(x.values())[0], reverse=True)  # 由大到小
                    financial_leverage_rank = assign_rank(sorted_financial_leverage, user_input_stock_code)

                    # 應收帳款收現日
                    sorted_ar_days = sorted(ar_days_list, key=lambda x: list(x.values())[0], reverse=True)  # 由大到小
                    ar_days_rank = assign_rank(sorted_ar_days, user_input_stock_code)

                    # 銷貨天數
                    sorted_sales_days = sorted(sales_days_list, key=lambda x: list(x.values())[0], reverse=True)  # 由大到小
                    sales_days_rank = assign_rank(sorted_sales_days, user_input_stock_code)


                    rank = {}

                    # 將排名結果存入字典
                    rank["毛利率排名"] = gross_margin_rank
                    rank["營業利益率排名"] = operating_margin_rank
                    rank["淨利率排名"] = net_margin_rank
                    rank["EPS排名"] = eps_rank
                    rank["經營安全邊際排名"] = safety_margin_rank
                    rank["ROE排名"] = roe_rank
                    rank["財務槓桿排名"] = financial_leverage_rank
                    rank["應收帳款收現日排名"] = ar_days_rank
                    rank["銷貨天數排名"] = sales_days_rank

                    # 輸出排名結果
                    for key, value in rank.items():
                        print(f"{key}: {value}")



                    
                    # 目標網站的 URL
                    url = 'https://mops.twse.com.tw/mops/web/ajax_t05st22'

                    # 固定公司代號
                    co_id = stock_code  # 假設 stock_code 是事先定義好的變量

                    # POST 請求的資料
                    data = {
                        'encodeURIComponent': '1',
                        'run': '',
                        'step': '1',
                        'TYPEK': 'sii',
                        'year': '', 
                        'isnew': 'true',
                        'co_id': co_id, 
                        'firstin': '1',
                        'off': '1',
                        'ifrs': 'Y',  
                    }

                    # 發送 POST 請求
                    response = requests.post(url, data=data)

                    # 確認請求是否成功
                    if response.status_code == 200:
                        # 解析返回的 HTML 內容
                        soup = BeautifulSoup(response.text, 'html.parser')
                        
                        # 找到具有 id="div01" 的 div
                        target_div = soup.find('div', id='div01')
                        
                        if target_div:
                            # 初始化結果字典
                            results = {}

                            # 定義需要查找的標題
                            target_titles = [
                                '存貨週轉率(次)',
                                "現金流量比率(%)",
                                "現金流量允當比率(%)",
                                "現金再投資比率(%)"
                            ]
                            
                            # 尋找所有表格行
                            rows = target_div.find_all('tr')

                            for row in rows:
                                # 提取所有標題和數據
                                headers = row.find_all('th')
                                data_cells = row.find_all('td')
                                
                                # 檢查是否有標題
                                for header in headers:
                                    header_text = header.get_text(strip=True)
                                    
                                    if header_text in target_titles:
                                        # 獲取對應的第三個 td
                                        third_td = data_cells[2].get_text(strip=True) if len(data_cells) > 2 else "NA"
                                        # 將鍵替換為不包含特殊字符的名稱
                                        safe_key = header_text.replace('(', '').replace(')', '').replace('%', '_percent')
                                        results[safe_key] = third_td

                            # 輸出結果到字典並替換 NA 為 0
                            for title, value in results.items():
                                if value == "NA":
                                    results[title] = 0  # 當 value 是 "NA" 時，設為 0
                                else:
                                    try:
                                        results[title] = float(value)  # 將 value 轉換為浮點數
                                    except ValueError:
                                        results[title] = 0  

                            # 現金流量比率_10 計算
                            if results.get('現金流量比率_percent'):
                                if results['現金流量比率_percent'] > 100:
                                    現金流量比率_10 = 10
                                else:
                                    現金流量比率_10 = results['現金流量比率_percent'] * 0.1
                                score_data['現金流量比率_10'] = round(現金流量比率_10, 2)   # 保持為數值類型
                            else:
                                score_data['現金流量比率_10'] = 0
                            # 現金允當比率_70 計算
                            if results.get('現金流量允當比率_percent'):
                                if results['現金流量允當比率_percent'] > 100:
                                    現金允當比率_70 = 70
                                else:
                                    現金允當比率_70 = results['現金流量允當比率_percent'] * 0.7
                                score_data['現金允當比率_70'] = round(現金允當比率_70, 2)  # 保持為數值類型
                            else:
                                score_data['現金允當比率_70'] = 0
                            # 現金再投資比率_20 計算
                            if results.get('現金再投資比率_percent') > 0:
                                if results['現金再投資比率_percent'] > 10:
                                    現金再投資比率_20 = 20
                                else:
                                    現金再投資比率_20 = results['現金再投資比率_percent'] * 2
                                score_data['現金再投資比率_20'] = round(現金再投資比率_20, 2)  # 保持為數值類型
                            else:
                                score_data['現金再投資比率_20'] = 0

                            # 提取存貨週轉率並存入 calculations
                            if results.get('存貨週轉率次'):
                                calculations['存貨週轉率次'] = round(results['存貨週轉率次'], 2)  # 保持為數值類型
                                calculations['銷貨天數'] = round(365 / calculations['存貨週轉率次'] , 2)  # 計算銷貨天數
                            else:
                                calculations['存貨週轉率次'] = 0
                                calculations['銷貨天數'] = 0  # 若沒有存貨週轉率則銷貨天數也設為0

                            # 計算現金流量表分數
                            print("計算現金流量表分數:")

                            # 確保每個值都是數字類型，非數字類型（如 None 或 "NA"）則設為 0
                            score_data['現金流量表分數'] = round(
                                (score_data.get('現金流量比率_10', 0) or 0) + 
                                (score_data.get('現金允當比率_70', 0) or 0) + 
                                (score_data.get('現金再投資比率_20', 0) or 0), 2
                            )


                            print(f"現金流量表分數: {score_data['現金流量表分數']:.2f}\n")


                            # 輸出最終結果字典
                            print("結果字典:", results)


                except ValueError as e:
                    print(f"計算時發生錯誤: {e}")



                # 合併計算結果
                combined_results.update(calculations)


                # 在終端機上顯示提取和計算的數據
                print("提取和計算的數據:")
                for key, value in combined_results.items():
                    print(f"{key}: {value}")

                # 生成 HTML 表格
                reports = [
                    {'report_type': '資產負債表', 'content': df_B.to_html(index=False, na_rep='', classes='report-table')},
                    {'report_type': '綜合損益表', 'content': df_P.to_html(index=False, na_rep='', classes='report-table')},
                    {'report_type': '現金流量表', 'content': df_C.to_html(index=False, na_rep='', classes='report-table')},
                ]

                # 將報表傳遞給模板
                return render(request, 'display_reports.html', {
                    'reports': reports,
                    'score_data': score_data,
                    'stock_code': stock_code, 
                    'results' : results,
                    'results_dict' : results_dict,
                    'calculations' : calculations,
                    'rank' : rank,


                })

            
            except Stock.DoesNotExist:
                print('股票代碼不存在。')
    return render(request, 'query_report.html')





def update_reports(request):
    csv_dir_path = os.path.join(os.path.dirname(__file__), 'csv')
    csv_files = [f'stock{i}.csv' for i in range(1, 6)]
    all_failed_stock_codes = []  # 用於存儲所有失敗的股票代號
    all_stock_codes = []

    for csv_file in csv_files:
        csv_file_path = os.path.join(csv_dir_path, csv_file)
        df = pd.read_csv(csv_file_path, encoding='big5')
        stock_codes = df['code'].tolist()
        all_stock_codes.extend(stock_codes)  # 將當前文件的股票代號加入列表

        # 修改：假設 validate_and_save_reports_from_csv 返回兩部分，失敗的股票代號和成功更新的股票代號
        failed_stock_codes, _ = validate_and_save_reports_from_csv(csv_file_path, batch_size=5)

        if failed_stock_codes:
            all_failed_stock_codes.extend(failed_stock_codes)  # 合併所有失敗的股票代號

    # 對於成功更新的所有股票代號，計算並存入 StockMetrics
    for stock_code in all_stock_codes:
            try:
                # 從資料庫獲取股票資料
                stock = Stock.objects.get(stock_code=stock_code)

                # 轉換 HTML 內容為 DataFrame
                def html_to_df(html):
                    try:
                        return pd.read_html(StringIO(html))[0]
                    except ValueError:
                        return pd.DataFrame()  # 返回空的 DataFrame，表示找不到表格

                df_B = html_to_df(stock.B)
                df_P = html_to_df(stock.P)
                df_C = html_to_df(stock.C)

                # 根據實際需要刪除其他不必要的欄位
                df_B = df_B.iloc[:, :-2]  # 根據實際需要調整
                df_P = df_P.iloc[:, :-1]  # 根據實際需要調整
                df_C = df_C.iloc[:, :-4]  # 根據實際需要調整

                # 如果 DataFrame 是空的，顯示未找到報表的訊息
                if df_B.empty and df_P.empty and df_C.empty:
                    print('未找到報表')
                    return

                # 提取數據的內嵌函數
                def extract_data_from_html(html_content):
                    soup = BeautifulSoup(html_content, 'html.parser')
                    data = {}

                    # 可指定提取哪一列的值
                    def extract_value(label, column_index=1, occurrence=1):
                        found_values = []
                        rows = soup.find_all('tr')
                        for row in rows:
                            columns = row.find_all('td')
                            if len(columns) > column_index:
                                cell_label = columns[0].get_text(strip=True)
                                if cell_label == label:
                                    found_values.append(columns[column_index].get_text(strip=True))
                        if occurrence <= len(found_values):
                            return found_values[occurrence - 1]
                        return None

                    return {
                        '現金及約當現金': extract_value('現金及約當現金'),
                        '負債總額': extract_value('負債總額') or extract_value('負債總計'),
                        '資產總額': extract_value('資產總額') or extract_value('資產總計'),
                        '應收帳款淨額': extract_value('應收帳款淨額') or extract_value('應收款項－淨額'),  # 取第三列
                        '營業收入合計': extract_value('營業收入合計') or extract_value('淨收益'),
                        '毛利率': extract_value('營業毛利（毛損）', column_index=2),  
                        '營業利益率': extract_value('營業利益（損失）', column_index=2),
                        '淨利率': extract_value('本期淨利（淨損）', column_index=2) or extract_value('本期稅後淨利（淨損）', column_index=2),
                        '本期淨利（淨損）': extract_value('本期淨利（淨損）') or extract_value('本期稅後淨利（淨損）'),
                        'EPS': extract_value('基本每股盈餘', occurrence=2),  # 取第二個
                        '權益總額': extract_value('權益總額') or extract_value('權益總計'),
                        '非流動資產合計': extract_value('非流動資產合計'),
                        '非流動負債合計': extract_value('非流動負債合計'),
                        '流動資產合計': extract_value('流動資產合計'),
                        '流動負債合計': extract_value('流動負債合計'),
                        '發放現金股利': extract_value('發放現金股利'),
                        '存貨': extract_value('存貨'),

                        '應收款項－淨額': extract_value('應收款項－淨額'),
                        '附賣回票券及債券投資': extract_value('附賣回票券及債券投資'),
                        '不動產及設備－淨額': extract_value('不動產及設備－淨額'),
                        '投資性不動產－淨額': extract_value('投資性不動產－淨額'),
                        '使用權資產－淨額': extract_value('使用權資產－淨額'),
                        '無形資產－淨額': extract_value('無形資產－淨額'),

                    }

                # 提取數據
                results_B = extract_data_from_html(stock.B)
                results_P = extract_data_from_html(stock.P)
                results_C = extract_data_from_html(stock.C)

                # 合併數據
                combined_results = {}
                combined_results.update({k: v for k, v in results_B.items() if v is not None})
                combined_results.update({k: v for k, v in results_P.items() if v is not None})
                combined_results.update({k: v for k, v in results_C.items() if v is not None})

                # 計算額外的數據
                calculations = {}
                score_data = {}
                try:
                    毛利率 = float(combined_results.get('毛利率', '0').replace(',', ''))
                    營業利益率 = float(combined_results.get('營業利益率', '0').replace(',', ''))
                    本期淨利 = float(combined_results.get('本期淨利（淨損）', '0').replace(',', ''))
                    權益總額 = float(combined_results.get('權益總額', '0').replace(',', ''))
                    淨利率 = float(combined_results.get('淨利率', '0').replace(',', ''))
                    EPS = float(combined_results.get('EPS', '0').replace(',', ''))
                    負債總額 = float(combined_results.get('負債總額', '0').replace(',', ''))
                    資產總額 = float(combined_results.get('資產總額', '0').replace(',', ''))
                    現金及約當現金 = float(combined_results.get('現金及約當現金', '0').replace(',', ''))
                    應收帳款 = float(combined_results.get('應收帳款淨額', '0').replace(',', ''))
                    營業收入 = float(combined_results.get('營業收入合計', '0').replace(',', ''))
                    流動資產 = float(combined_results.get('流動資產合計', '0').replace(',', ''))
                    存貨 = float(combined_results.get('存貨', '0').replace(',', ''))
                    股利 = float(combined_results.get('發放現金股利', '0').replace(',', ''))
                    非流動資產 = float(combined_results.get('非流動資產合計', '0').replace(',', ''))
                    非流動負債 = float(combined_results.get('非流動負債合計', '0').replace(',', ''))
                    流動負債 = float(combined_results.get('流動負債合計', '0').replace(',', ''))
                    應收款項 = float(combined_results.get('應收款項－淨額', '0').replace(',', ''))
                    附賣回票券及債券投資 = float(combined_results.get('附賣回票券及債券投資', '0').replace(',', ''))
                    不動產及設備 = float(combined_results.get('不動產及設備－淨額', '0').replace(',', ''))
                    投資性不動產 = float(combined_results.get('投資性不動產－淨額', '0').replace(',', ''))
                    使用權資產 = float(combined_results.get('使用權資產－淨額', '0').replace(',', ''))
                    無形資產 = float(combined_results.get('無形資產－淨額', '0').replace(',', ''))


                    #輸出值等於零的鍵
                    # 新建一個字典來存放變數和值
                    financial_data = {
                        '毛利率': float(combined_results.get('毛利率', '0').replace(',', '')),
                        '營業利益率': float(combined_results.get('營業利益率', '0').replace(',', '')),
                        '本期淨利': float(combined_results.get('本期淨利（淨損）', '0').replace(',', '')),
                        '權益總額': float(combined_results.get('權益總額', '0').replace(',', '')),
                        '淨利率': float(combined_results.get('淨利率', '0').replace(',', '')),
                        'EPS': float(combined_results.get('EPS', '0').replace(',', '')),
                        '負債總額': float(combined_results.get('負債總額', '0').replace(',', '')),
                        '資產總額': float(combined_results.get('資產總額', '0').replace(',', '')),
                        '現金及約當現金': float(combined_results.get('現金及約當現金', '0').replace(',', '')),
                        '應收帳款': float(combined_results.get('應收帳款淨額', '0').replace(',', '')),
                        '營業收入': float(combined_results.get('營業收入合計', '0').replace(',', '')),
                        '流動資產': float(combined_results.get('流動資產合計', '0').replace(',', '')),
                        '存貨': float(combined_results.get('存貨', '0').replace(',', '')),
                        '股利': float(combined_results.get('發放現金股利', '0').replace(',', '')),
                        '非流動資產': float(combined_results.get('非流動資產合計', '0').replace(',', '')),
                        '非流動負債': float(combined_results.get('非流動負債合計', '0').replace(',', '')),
                        '流動負債': float(combined_results.get('流動負債合計', '0').replace(',', '')),
                        '應收款項': float(combined_results.get('應收款項－淨額', '0').replace(',', '')),
                        '附賣回票券及債券投資': float(combined_results.get('附賣回票券及債券投資', '0').replace(',', '')),
                        '不動產及設備': float(combined_results.get('不動產及設備－淨額', '0').replace(',', '')),
                        '投資性不動產': float(combined_results.get('投資性不動產－淨額', '0').replace(',', '')),
                        '使用權資產': float(combined_results.get('使用權資產－淨額', '0').replace(',', '')),
                        '無形資產': float(combined_results.get('無形資產－淨額', '0').replace(',', '')),
                    }
                    
                    # 將值等於零的鍵連接成一行輸出在終端機
                    zero_keys = [key for key, value in financial_data.items() if value == 0]
                    if zero_keys:
                        print(f"值等於零的鍵: {', '.join(zero_keys)}")




                    if 流動資產 == 0:
                        # 計算流動負債的值 (假設你有其他計算方法，這裡以示例計算)
                        流動資產 = 現金及約當現金 + 應收款項 + 附賣回票券及債券投資
                        calculations['流動資產'] = f'{流動資產:.2f}'

                    if 非流動資產 == 0:
                        非流動資產=不動產及設備 + 投資性不動產 + 使用權資產 + 無形資產
                        calculations['非流動資產'] = f'{非流動資產:.2f}'

                    if 股利 == 0:
                        csv_file_path = os.path.join(os.path.dirname(__file__), 'csv', 'day.csv')
                        # 檢查 CSV 檔案是否存在
                        if os.path.exists(csv_file_path):
                            # 讀取 CSV 檔案，指定編碼
                            df_csv = pd.read_csv(csv_file_path, encoding='big5')
                            
                            # 確保 CSV 中包含 'code' 和 'day' 欄位
                            if 'code' in df_csv.columns and 'dividend' in df_csv.columns:
                                # 將 'code' 欄位轉換為數字型別
                                df_csv['code'] = pd.to_numeric(df_csv['code'], errors='coerce')
                                
                                # 將使用者輸入的 stock_code 轉換為數字型別
                                try:
                                    stock_code_numeric = float(stock_code)
                                except ValueError:
                                    print(f"使用者輸入的 code '{stock_code}' 不是有效的數字。")
                                    stock_code_numeric = None
                                
                                if stock_code_numeric is not None:
                                    # 查找使用者輸入的 code 對應的行
                                    matching_rows = df_csv[df_csv['code'] == stock_code_numeric]

                                    # 檢查是否找到了對應的行
                                    if not matching_rows.empty:
                                        股利= matching_rows['dividend'].values[0]  
                                        calculations['股利'] = 股利
                                    else:
                                        print(f"CSV 檔案中找不到 code '{stock_code}' 的數據")
                                else:
                                    print("無法將使用者輸入的 code 轉換為數字。")
                            else:
                                print("CSV 檔案中找不到 'code' 或 'dividend' 欄位")
                        else:
                            print("CSV 檔案不存在")

                    # 損益表
                    if 毛利率 :
                        毛利率_20 = 毛利率 * 0.2
                        score_data['毛利率_20'] = f'{毛利率_20:.2f}'
                    else:
                        毛利率 = 0
                        score_data['毛利率_20'] = 0

                    if 營業利益率 :
                        營業利益率_20 = 營業利益率 * 0.2
                        score_data['營業利益率_20'] = f'{營業利益率_20:.2f}' 
                    else:
                        營業利益率 = 0
                        score_data['營業利益率_20'] = 0                   

                    if 毛利率 :
                        經營安全邊際 = 營業利益率 / 毛利率
                        if 經營安全邊際 > 0.6:
                            經營安全邊際_20 = 20
                        else:
                            經營安全邊際_20 = 經營安全邊際 * (100 / 3)
                        calculations['經營安全邊際'] = f'{經營安全邊際:.2f}'
                        score_data['經營安全邊際_20'] = f'{經營安全邊際_20:.2f}'
                    else:
                        經營安全邊際 = 0
                        calculations['經營安全邊際'] = 0
                        score_data['經營安全邊際_20'] = 0

                    if 淨利率 != 0:
                        淨利率_10 = 淨利率 * 0.1
                        score_data['淨利率_10'] = f'{淨利率_10:.2f}'

                    if EPS != 0:
                        EPS_10 = EPS * 0.1
                        score_data['EPS_10'] = f'{EPS_10:.2f}'

                    if (本期淨利 != 0) and (權益總額 != 0):
                        ROE = 本期淨利 / 權益總額
                        if ROE > 0.2:
                            ROE_20 = 20
                        else:
                            ROE_20 = ROE * 100
                        calculations['ROE'] = f'{ROE:.2f}'
                        score_data['ROE_20'] = f'{ROE_20:.2f}'

                    # 資產負債表
                    if (權益總額 != 0) and (資產總額 != 0):
                        財務槓桿 = 權益總額 / 資產總額
                        財務槓桿_50 = 財務槓桿 * 50
                        calculations['財務槓桿'] = f'{財務槓桿:.2f}'
                        score_data['財務槓桿_50'] = f'{財務槓桿_50:.2f}'

                    if (現金及約當現金 != 0) and (資產總額 != 0):
                        現金及約當現金_資產總額 = 現金及約當現金 / 資產總額
                        if 現金及約當現金_資產總額 < 0.1:
                            現金及約當現金_資產總額_p = 0
                        elif 現金及約當現金_資產總額 > 0.25:
                            現金及約當現金_資產總額_p = (現金及約當現金_資產總額 - 0.25) * 5
                        else:
                            現金及約當現金_資產總額_p = 5
                        calculations['現金及約當現金_資產總額'] = f'{現金及約當現金_資產總額:.2f}'
                        score_data['現金及約當現金_資產總額_p'] = f'{現金及約當現金_資產總額_p:.2f}'

                    if (應收帳款 != 0) and (營業收入 != 0):
                        應收帳款收現日 = (應收帳款 / 營業收入) * 365
                        應收帳款收現日_25 = 應收帳款收現日 * 0.25
                        if 應收帳款收現日_25 > 25:
                            應收帳款收現日_25 = 25
                        calculations['應收帳款收現日'] = f'{應收帳款收現日:.2f}'
                        score_data['應收帳款收現日_25'] = f'{應收帳款收現日_25:.2f}'

                    # 確保 CSV 檔案路徑正確
                    csv_file_path = os.path.join(os.path.dirname(__file__), 'csv', 'day.csv')

                    # 檢查 CSV 檔案是否存在
                    if os.path.exists(csv_file_path):
                        # 讀取 CSV 檔案，指定編碼
                        df_csv = pd.read_csv(csv_file_path, encoding='big5')
                        
                        # 確保 CSV 中包含 'code' 和 'day' 欄位
                        if 'code' in df_csv.columns and 'day' in df_csv.columns:
                            # 將 'code' 欄位轉換為數字型別
                            df_csv['code'] = pd.to_numeric(df_csv['code'], errors='coerce')
                            
                            # 將使用者輸入的 stock_code 轉換為數字型別
                            try:
                                stock_code_numeric = float(stock_code)
                            except ValueError:
                                print(f"使用者輸入的 code '{stock_code}' 不是有效的數字。")
                                stock_code_numeric = None
                            
                            if stock_code_numeric is not None:
                                # 查找使用者輸入的 code 對應的行
                                matching_rows = df_csv[df_csv['code'] == stock_code_numeric]

                                # 檢查是否找到了對應的行
                                if not matching_rows.empty:
                                    # 取得對應的 'day' 欄位值
                                    day= matching_rows['day'].values[0]  # 取得對應的 'day' 值
                                    calculations['day'] = day
                                else:
                                    print(f"CSV 檔案中找不到 code '{stock_code}' 的數據")
                            else:
                                print("無法將使用者輸入的 code 轉換為數字。")
                        else:
                            print("CSV 檔案中找不到 'code' 或 'day' 欄位")
                    else:
                        print("CSV 檔案不存在")

                    # 讀取 day 值並進行條件檢查
                    if 'day' in calculations:
                        day_value = float(calculations['day'])
                        
                        # 半導體、電腦及週邊設備、電子零組件、光電業、其他電子通信網路
                        if stock_code in ['2330', '2317', '2454', '2308', '2382', '3711', '2357', '3034', '2412', '2395',
                                          '3008', '2345', '2327', '3231', '2379', '4938', '2301', '3661', '6669', '2207',
                                          '3017', '3045', '4904', '1590', '2408']:
                            if day_value < 60:
                                day_25 = ((day_value - 60) / 50) * 25
                                score_data['day_25'] = f'{day_25:.2f}'
                            elif 60 <= day_value <= 90:
                                day_25 = 25
                                score_data['day_25'] = f'{day_25:.2f}'
                            else:
                                day_25 = ((day_value - 90) / 90) * 25
                                score_data['day_25'] = f'{day_25:.2f}'
                        # 金融保險
                        elif stock_code in ['2881', '2883', '2887', '2882', '2886', '2884', '2885', '2890', '2892', '2880', '5880', '5876', '5871']:
                            day_25 = 0
                            score_data['day_25'] = f'{day_25:.2f}'
                        
                        # 塑膠/鋼鐵
                        elif stock_code in ['1303', '1301', '1326', '6505', '2002', '3037', '1101', '1216', '2912']:
                            if 40 <= day_value <= 60:
                                day_25 = 25
                                score_data['day_25'] = f'{day_25:.2f}'
                            elif day_value < 40:
                                day_25 = ((day_value - 40) / 40) * 25
                                score_data['day_25'] = f'{day_25:.2f}'
                            else:
                                day_25 = ((day_value - 60) / 60) * 25
                                score_data['day_25'] = f'{day_25:.2f}'
                        # 食品    
                        elif stock_code in ['1216', '2912']:
                            if day_value < 15:
                                day_25 = 25
                                score_data['day_25'] = f'{day_25:.2f}'
                            else:
                                day_25 = 0
                                score_data['day_25'] = f'{day_25:.2f}'        

                        # 其他
                        else:
                            day_25 = 0
                            score_data['day_25'] = f'{day_25:.2f}'



                    # 現金流量表
                    if (現金及約當現金 != 0) and (流動資產 != 0):
                        現金流量比率 = 現金及約當現金 / 流動資產
                        if 現金流量比率 > 1:
                            現金流量比率_10 = 10
                        else:
                            現金流量比率_10 = 現金流量比率 * 10
                        calculations['現金流量比率'] = f'{現金流量比率:.2f}'
                        score_data['現金流量比率_10'] = f'{現金流量比率_10:.2f}'

                    if (現金及約當現金 != 0) and (存貨 != 0) and (股利 != 0):
                        現金允當比率 = 現金及約當現金 / (存貨 + 股利)
                        if 現金允當比率 > 1:
                            現金允當比率_70 = 70
                        else:
                            現金允當比率_70 = 現金允當比率 * 70
                        calculations['現金允當比率'] = f'{現金允當比率:.2f}'
                        score_data['現金允當比率_70'] = f'{現金允當比率_70:.2f}'

                    if (現金及約當現金 != 0) and (非流動資產 != 0) and (權益總額 != 0):
                        現金再投資比率 = 現金及約當現金 / (非流動資產 +(非流動負債 + 權益總額) / 非流動資產 +(流動資產 - 流動負債))
                        if 現金再投資比率 > 0.1:
                            現金再投資比率_20 = 20
                        else:
                            現金再投資比率_20 = 現金再投資比率 * 2
                        calculations['現金再投資比率'] = f'{現金再投資比率:.2f}'
                        score_data['現金再投資比率_20'] = f'{現金再投資比率_20:.2f}'


                    # 計算總計
                    B = 0
                    print("計算資產負債表分數:")
                    for key in ['財務槓桿_50', '現金及約當現金_資產總額_p', '應收帳款收現日_25', 'day_25']:
                        value = score_data.get(key, 0)  # 預設值設為整數 0
                        try:
                            B += float(value)
                            print(f"{key}: {value}, 累加後的B: {B}")
                        except ValueError:
                            print(f"{key}: 無效值 '{value}', 略過此項目")
                    score_data['資產負債表分數'] = f'{B:.2f}' 
                    print(f"資產負債表分數: {score_data['資產負債表分數']}\n")

                    # 計算綜合損益表分數
                    P = 0
                    print("計算綜合損益表分數:")
                    for key in ['毛利率_20', '營業利益率_20', '經營安全邊際_20', '淨利率_10', 'EPS_10', 'ROE_20']:
                        value = score_data.get(key, 0)  # 預設值設為整數 0
                        try:
                            P += float(value)
                            print(f"{key}: {value}, 累加後的P: {P}")
                        except ValueError:
                            print(f"{key}: 無效值 '{value}', 略過此項目")
                    score_data['綜合損益表分數'] = f'{P:.2f}'
                    print(f"綜合損益表分數: {score_data['綜合損益表分數']}\n")

                    # 計算現金流量表分數
                    C = 0
                    print("計算現金流量表分數:")
                    for key in ['現金流量比率_10', '現金允當比率_70', '現金再投資比率_20']:
                        value = score_data.get(key, 0)  # 預設值設為整數 0
                        try:
                            C += float(value)
                            print(f"{key}: {value}, 累加後的C: {C}")
                        except ValueError:
                            print(f"{key}: 無效值 '{value}', 略過此項目")
                    score_data['現金流量表分數'] = f'{C:.2f}'
                    print(f"現金流量表分數: {score_data['現金流量表分數']}\n")


                    co_id = stock_code  # 假設 stock_code 是事先定義好的變量

                    # POST 請求的資料
                    data = {
                        'encodeURIComponent': '1',
                        'run': '',
                        'step': '1',
                        'TYPEK': 'sii',
                        'year': '', 
                        'isnew': 'true',
                        'co_id': co_id, 
                        'firstin': '1',
                        'off': '1',
                        'ifrs': 'Y',  
                    }

                    # 發送 POST 請求
                    response = requests.post('https://mops.twse.com.tw/mops/web/ajax_t05st22', data=data)

                    # 確認請求是否成功
                    if response.status_code == 200:
                        # 解析返回的 HTML 內容
                        soup = BeautifulSoup(response.text, 'html.parser')
                        
                        # 找到具有 id="div01" 的 div
                        target_div = soup.find('div', id='div01')
                        
                        if target_div:
                            # 初始化結果字典
                            results = {}

                            # 定義需要查找的標題
                            target_titles = [
                                '存貨週轉率(次)',
                            ]
                            
                            # 尋找所有表格行
                            rows = target_div.find_all('tr')

                            for row in rows:
                                # 提取所有標題和數據
                                headers = row.find_all('th')
                                data_cells = row.find_all('td')
                                
                                # 檢查是否有標題
                                for header in headers:
                                    header_text = header.get_text(strip=True)
                                    
                                    if header_text in target_titles:
                                        # 獲取對應的第三個 td
                                        third_td = data_cells[2].get_text(strip=True) if len(data_cells) > 2 else "NA"
                                        # 將鍵替換為不包含特殊字符的名稱
                                        safe_key = header_text.replace('(', '').replace(')', '')
                                        results[safe_key] = third_td

                            # 輸出結果到字典並替換 NA 為 0
                            for title, value in results.items():
                                if value == "NA":
                                    results[title] = 0  # 當 value 是 "NA" 時，設為 0
                                else:
                                    try:
                                        results[title] = float(value)  # 將 value 轉換為浮點數
                                    except ValueError:
                                        results[title] = 0  
                            
                        
                            if '存貨週轉率次' in results and results['存貨週轉率次'] != 0:
                                results['存貨週轉天數'] = 365 / results['存貨週轉率次']
                            else:
                                results['存貨週轉天數'] = 0



                    StockMetrics.objects.update_or_create(
                        stock_code=stock_code,  
                        defaults={              
                            '財務槓桿': 財務槓桿,
                            '應收帳款收現日': 應收帳款收現日,
                            '銷貨天數': results['存貨週轉天數'],
                            '加分項': 現金及約當現金_資產總額,
                            '毛利率': 毛利率,
                            '營業利益率': 營業利益率,
                            '淨利率': 淨利率,
                            'EPS': EPS,
                            '經營安全邊際': 經營安全邊際,
                            'ROE': ROE,
                        }
                    )

                except ValueError as e:
                    print(f"計算時發生錯誤: {e}")



                # 合併計算結果
                combined_results.update(calculations)

            except Stock.DoesNotExist:
                all_failed_stock_codes.append(stock_code)  # 股票代碼不存在的情況

    # 顯示爬取失敗的結果
    update_messages = []
    if all_failed_stock_codes:
        update_messages.append("以下股票代號未能成功抓取報表:")
        update_messages.append(", ".join(map(str, all_failed_stock_codes)))  # 確保轉換為字串
    else:
        update_messages.append("所有表單都已成功抓取並計算分數。")

    return render(request, 'update_reports.html', {'messages': update_messages})

